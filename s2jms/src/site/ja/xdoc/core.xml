<?xml version="1.0" encoding="UTF-8"?>
<document>
	<properties>
		<title>Core</title>
	</properties>
	<body>
		<section name="目次">
			<ul>
				<li><p><a href="#概要">概要</a></p></li>
				<li><p><a href="#MessageSender">MessageSender</a></p></li>
				<li><p><a href="#MessageReceiver">MessageReceiver</a></p></li>
				<li><p><a href="#Tips">Tips</a></p>
					<ul>
						<li><p><a href="#リクエスト～リプライ">リクエスト～リプライ</a></p></li>
					</ul>
				</li>
			</ul>
		</section>

		<section name="概要">
			<p>
				S2JMS-Coreは，JMSメッセージを容易に送受信するためのコンポーネントを提供します．
				主なコンポーネントのインタフェースは次の二つです．
			</p>
			<dl>
				<dt>MessageSender</dt>
				<dd>
					JMSメッセージを送信する場合に使用するコンポーネントのインタフェースです．
				</dd>
				<dt>MessageReceiver</dt>
				<dd>
					JMSメッセージを受信する場合に使用するコンポーネントのインタフェースです．
				</dd>
			</dl>
			<p>
				いずれもdiconファイルに定義し，アプリケーションはS2コンテナからDIされたコンポーネントを使用します．
				diconファイルへの定義については，
				「<a href="config.html">コンフィグレーション</a>」－「<a href="config-outbound.html">アウトバウンド通信</a>」を参照してください．
			</p>
		</section>

		<section name="MessageSender">
			<p>
				<code>MessageSender</code>は、JMSメッセージを送信するコンポーネントです。
			</p>
			<p>
			送信するJMSメッセージを容易に作成するために次のメソッドを使用することができます。
			</p>
			<ul>
				<li><p>
					<code>void send(byte[] bytes)</code>
					<div>
						引数で指定されたバイト列をペイロードデータとする<code>BytesMessage</code>を作成して送信します。
					</div>
				</p></li>
				<li><p>
					<code>void send(Map&lt;String, Object&gt; map)</code>
					<div>
						引数で指定された<code>Map</code>に含まれるマッピングをペイロードデータとする<code>MapMessage</code>を作成して送信します。
					</div>
				</p></li>
				<li><p>
					<code>void send(Serializable object)</code>
					<div>
						引数で指定されたオブジェクトをペイロードデータとする<code>ObjectMessage</code>を作成して送信します。
					</div>
				</p></li>
				<li><p>
					<code>void send(String text)</code>
					<div>
						引数で指定された文字列をペイロードデータとする<code>TextMessage</code>を作成して送信します。
					</div>
				</p></li>
			</ul>
			<p>
				例えば，<code>TextMessage</code>を送信する場合は次のようになります．
			</p>
<source><![CDATA[
    String text = ...;
    sender.send(text);
]]></source>
			<p>
				作成されるJMSメッセージのヘッダを指定するには、次のメソッドを使用します。
			</p>
			<ul>
				<li><p><code>MessageSender setCorrelationID(final String correlationID)</code></p></li>
				<li><p><code>MessageSender setCorrelationIDAsBytes(final byte[] correlationIDAsBytes)</code></p></li>
				<li><p><code>MessageSender setReplyTo(Destination replyTo)</code></p></li>
			</ul>
			<p>
				作成されるJMSメッセージのプロパティを指定するには、次のメソッドを使用します。
			</p>
			<ul>
				<li><p><code>MessageSender addProperty(String name, Object value)</code></p></li>
				<li><p><code>MessageSender addProperties(Map&lt;String, Object&gt; properties)</code></p></li>
			</ul>
			<p>
				例えば，次のようになります．
			</p>
<source><![CDATA[
    sender.setCorrelationID(correlationID);
    sender.addProperty("reply", true);
    sender.send(text);
]]></source>
			<p>
				送信するJMSメッセージをより詳細に設定するには次のメソッドを使用します。
			</p>
			<ul>
				<li><p>
					<code>&lt;MSGTYPE extends Message&gt; send(MessageFactory)</code>
					<div>
						引数で指定された<code>MessageFactory</code>が作成したJMSメッセージを送信します。
					</div>
				</p></li>
				<li><p>
					<code>send()</code>
					<div>
						<code>MessageSender</code>のプロパティに設定された<code>MessageFactory</code>が作成したJMSメッセージを送信します。
					</div>
				</p></li>
			</ul>
			<p>
				送信されたJMSメッセージを取得するには、次のメソッドを使用します。
			</p>
			<ul>
				<li><p><code>Message getMessage()</code></p></li>
			</ul>
			<p>
				例えば，次のようになります．
			</p>
<source><![CDATA[
    sender.send(text);
    Message sentMessage = sender.getMessage();
]]></source>
			<p>
				送信されたJMSメッセージのヘッダを取得するには、次のメソッドを使用します。
			</p>
			<ul>
				<li><p><code>String getMessageID()</code></p></li>
				<li><p><code>long getTimestamp()</code></p></li>
				<li><p><code>long getExpiration()</code></p></li>
			</ul>
			<p>
				例えば，次のようになります．
			</p>
<source><![CDATA[
    sender.send(text);
    String messageID = sender.getMessageID();
]]></source>
		</section>

		<section name="MessageReceiver">
			<p>
				<code>MessageReceiver</code>は、JMSメッセージを受信するコンポーネントです。
			</p>
			<p>
				受信したメッセージを容易に処理するために次のメソッドを使用することができます。
			</p>
			<ul>
				<li><p>
					<code>byte[] receiveBytes()</code>
					<div>
						受信した<code>BytesMessage</code>のペイロードデータであるバイト列を返します。
					</div>
				</p></li>
				<li><p>
					<code>Map&lt;String, Object&gt; receiveMap()</code>
					<div>
						受信した<code>MapMessage</code>のペイロードデータに含まれるマッピングを持つ<code>Map</code>を返します。
					</div>
				</p></li>
				<li><p>
					<code>Object receiveObject()</code>
					<div>
						受信した<code>ObjectMessage</code>のペイロードデータであるオブジェクトを返します。
					</div>
				</p></li>
				<li><p>
					<code>String receiveText()</code>
					<div>
						受信した<code>TextMessage</code>のペイロードデータである文字列を返します。
					</div>
				</p></li>
			</ul>
			<p>
				例えば，<code>TextMessage</code>を受信する場合は次のようになります．
			</p>
<source><![CDATA[
    String text = receiver.receiveText();
]]></source>
			<p>
				受信したJMSメッセージを独自に処理するには次のメソッドを使用することができます。
			</p>
			<ul>
				<li><p>
					<code>&lt;MSGTYPE extends Message, T&gt; T receive(MessageHandler&lt;MSGTYPE, T&gt; messageHandler)</code>
					<div>
						引数で指定する<code>MessageHandler</code>により自由にJMSメッセージを処理することができます。
						このメソッドは<code>MessageHandler#handleMessage(Message)</code>の戻り値をそのまま返します。
					</div>
				</p></li>
			</ul>
			<p>
				受信したJMSメッセージをそのまま取得するには次のメソッドを使用することができます。
			</p>
			<ul>
				<li><p><code>Message receive()</code></p></li>
			</ul>
			<p>
				受信可能なJMSメッセージがまだ到着していない場合の動作は次のメソッドで設定します．
			</p>
			<ul>
				<li><p>
					<code>MessageReceiver setTimeout(long timeout)</code>
					<div>
						<code>timeout</code>に指定する値は次のようになります．
						<dl>
							<dt>正の数</dt>
							<dd>
								JMSメッセージを受信するまで指定された時間待機します (ミリ秒単位)。
							</dd>
							<dt><code>0</code></dt>
							<dd>
								JMSメッセージが受信できなければ待機しません。
							</dd>
							<dt>負の数</dt>
							<dd>
								JMSメッセージを受信するまで無期限に待機します。
							</dd>
						</dl>
					</div>
				</p></li>
			</ul>
			<p>
				受信するJMSメッセージを選択するために次のメソッドを使用することができます。
			</p>
			<ul>
				<li><p><code>MessageReceiver setMessageSelector(String messageSelector)</code></p></li>
			</ul>
			<p>
				受信したJMSメッセージを取得するには、次のメソッドを使用します。
				<code>receiveText()</code>等を呼び出した後でもJMSメッセージを取得することができます．
			</p>
			<ul>
				<li><p><code>void getMessage()</code></p></li>
			</ul>
			<p>
				受信したJMSメッセージのヘッダを取得するには、次のメソッドを使用します。
			</p>
			<ul>
				<li><p><code>void getMessageID()</code></p></li>
				<li><p><code>void getTimestamp()</code></p></li>
				<li><p><code>void getExpiration()</code></p></li>
			</ul>
		</section>

		<section name="Tips">
			<subsection name="リクエスト～リプライ">
				<p>
					要求メッセージを送信した後に応答メッセージを受信する，リクエスト～リプライ型のアプリケーションは次のように実現することができます．
				</p>
<source><![CDATA[
    public String send(String requestMessage) {
        sender.send(requestMessage);
        String messageID = sender.getMessageID();
        return messageID;
    }

    public String receive(String messageID) {
        receiver.setMessageSelector("JMSCorrelationID = '" + messageID + "'");
        String replyMessage = receiver.receiveText();
        return replyMessage;
    }
]]></source>
				<p>
					送信した要求メッセージの<code>JMSMessageID</code>ヘッダの値と一致する
					<code>JMSCorrelationID</code>ヘッダを持つメッセージだけを受信するように，
					<code>messageSelector</code>を指定します．
				</p>
				<p>
					リクエスト～リプライ型のアプリケーションでは，要求メッセージの送信 (<code>send(String)</code>) と
					応答メッセージの受信 (<code>receive(String)</code>) は別のトランザクションにする必要があります．
					同じトランザクションにすると，トランザクションがコミットするまで相手側は要求メッセージを受信することができません．
					そのため応答メッセージが返ってくることもなく，受信処理は完了しません．
				</p>
			</subsection>
		</section>
	</body>
</document>
