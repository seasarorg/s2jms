<?xml version="1.0" encoding="UTF-8"?>
<document>
	<properties>
		<title>Core</title>
	</properties>
	<body>
		<section name="目次">
			<ul>
				<li><p><a href="#概要">概要</a></p></li>
				<li><p><a href="#メッセージのバインド">メッセージのバインド</a></p>
					<ul>
				  	    <li><p><a href="#メッセージヘッダのバインド">メッセージヘッダのバインド</a></p></li>
				  	    <li><p><a href="#メッセージプロパティのバインド">メッセージプロパティのバインド</a></p></li>
				  	    <li><p><a href="#メッセージペイロードデータのバインド">メッセージペイロードデータのバインド</a></p></li>
					</ul>
				</li>
		  	    <li><p><a href="#リスナ・メソッド">リスナ・メソッド</a></p></li>
				<li><p><a href="#リクエスト～リプライ">リクエスト～リプライ</a></p></li>
			</ul>
		</section>

		<section name="概要">
			<p>
				S2JMS-Containerは，POJO (Plain Old Java Object) がJMSのAPIを意識することなく，
				非同期通信によるメッセージを受信できるようにするためのコンポーネントです．
			</p>
			<p>
				通常，JMSによるインバウンドメッセージ受信アプリケーション (EJBのMessage-Driven Beanなど)
				を作成するには，以下の手順を踏みます．
			</p>
			<ol>
				<li><p><code>javax.jms.MessageListener</code>インターフェースを実装したクラスを作成する．</p></li>
				<li><p><code>onMessage(javax.jms.Message)</code>メソッドを作成する．</p></li>
			 	<li><p><code>onMessage(javax.jms.Message)</code>メソッドの中で，受信した<code>javax.jms.Message</code>を処理する．</p></li>
			</ol>
			<p>
				しかし，この場合作成したクラスはJMSのAPIに依存することになってしまいます．
			</p>
			<p>
				S2JMS-Containerを利用することで，JMSのAPIに依存しない受信コンポーネント (Message-Driven POJOs)
				を作ることができ，特に既存の資産をJMS受信アプリケーションに流用することが容易となります
				(このメッセージ受信コンポーネントを，「リスナ・コンポーネント」と呼びます)．
			</p>
			<p>
				S2JMS-Containerは，インバウンド通信によりJMSメッセージを受信すると，
				JMSメッセージのヘッダやプロパティ，ペイロードをリスナ・コンポーネントにバインドしてメッセージを処理するメソッドを呼び出します
				(このメソッドを，「リスナ・メソッド」と呼びます)．
				このため，リスナ・コンポーネントは<code>javax.jms.MessageListener</code>インターフェースを実装したり，
				JMSメッセージを直接扱ったりすることなく，メッセージを処理することができます．
			</p>
		</section>

		<section name="メッセージのバインド">
			<p>
				S2JMS-Containerを使用すると，受信したJMSメッセージのヘッダ，プロパティ，およびペイロードを，
				リスナ・コンポーネントにバインドすることができます．
			</p>

			<subsection name="メッセージヘッダのバインド">
				<p>
					リスナ・コンポーネントに対して，受信したメッセージのヘッダをバインドします．
				</p>

				<p>
					バインドしたいフィールドまたはsetterメソッドに <code>@JMSHeader</code> アノテーションを指定することで，
					該当するメッセージヘッダがバインドされます．
				</p>
			
				<p>
					以下のように，<code>@JMSHeader</code>アノテーションのみを指定した場合，
					フィールド名に一致するメッセージヘッダがバインドされます．
					この場合，フィールド名は"<code>correlationID</code>" ("<code>JMS</code>"というプレフィックスをつけない)
					または"<code>JMSCorrelationID</code>" ("<code>JMS</code>"というプレフィックスをつける) のどちらでも有効です．
				</p>
				<p>
					以下の例では，<code>correlationID</code>フィールドに，
					<code>JMSCorrelationID</code>ヘッダの値がバインドされます．
				</p>
<source><![CDATA[
    @JMSHeader
    private String correlationID;
]]></source>
				<p>
					以下のように，<code>name</code>メンバを利用してヘッダ名称を指定することもできます．
					この場合，フィールド名には関係なく<code>name</code>メンバで指定されたヘッダ名が使用されます．
					この場合もヘッダ名称には「JMS」プレフィックスをつけてもつけなくても構いません．
				</p>
<source><![CDATA[
    @JMSHeader(name = "deliveryMode")
    private int mode;
]]></source>
				<p>
					<code>@JMSHeader</code>アノテーションには，
					S2Containerの<code>bindingType</code>メンバも指定することができます．
				</p>
<source><![CDATA[
    @JMSHeader(bindingType = BindingType.MUST)
    private String JMSMessageID;
]]></source>
				<p>
					<code>bindingType</code>については，以下の表を参照してください．
				</p>
				<table width="100%" border="1">
					<tr align="center">
						<th>bindingType</th>
						<th>説明</th>
					</tr>
					<tr>
						<td><code>MUST</code></td>
						<td>バインドに失敗した場合､例外が発生します．
					</td>
					</tr>
					<tr>
						<td><code>SHOULD</code> (デフォルト)</td>
						<td>バインドに失敗した場合､警告を通知します．</td>
					</tr>
					<tr>
						<td><code>MAY</code></td>
						<td>バインドに失敗した場合，何もおきません．</td>
					</tr>
					<tr>
						<td><code>NONE</code></td>
						<td>バインドを行いません．</td>
					</tr>
				</table>
				<p>
					setterメソッドに対しても<code>@JMSHeader</code>アノテーションを指定することができます．
					<code>name</code>メンバを省略した場合，
					メソッド名から先頭の"<code>set</code>"を取り除いた名前がヘッダ名となります．
					この場合もヘッダ名称には「JMS」プレフィックスをつけてもつけなくても構いません．
				</p>
<source><![CDATA[
    private int priority;
    
    @JMSHeader(name = "JMSPriority", bindingType = BindingType.MUST)
    public void setPriority(int priority) {
      this.priority = priority;
    }
]]></source>
			</subsection>

			<subsection name="メッセージプロパティのバインド">
				<p>
					ヘッダと同様にメッセージのプロパティもバインドすることができます．
				</p>
				<p>
					以下のように，フィールドやsetterメソッドに<code>@JMSProperty</code>アノテーションのみを指定した場合，
					フィールド名に一致するメッセージプロパティがバインドされます．
					この例の場合，「foo」という名前のプロパティがバインドされます．
				</p>
<source><![CDATA[
  @JMSProperty
  private int foo;
]]></source>
<source><![CDATA[
  @JMSProperty
  public void setFoo(int foo){
      this.foo = foo;
  }
]]></source>
				<p>
					また，以下のように<code>name</code>メンバを利用してプロパティ名を明示することもできます．
				</p>
<source><![CDATA[
  @JMSProperty(name = "baz")
  public void setBar(String bar) {
      this.bar = bar;
  }
]]></source>
				<p>
					<code>@JMSProperty</code>アノテーションの付けられたフィールドまたはプロパティの型が
					<code>java.util.Map</code>の場合は，
					全てのメッセージプロパティの名前とその値のマッピングを持つ<code>Map&lt;String, Object&gt;</code>が
					バインドされます．
				</p>
<source><![CDATA[
  @JMSProperty
  private Map<String, Object> properties;
]]></source>
				<p>
					<code>@JMSProperty</code>アノテーションにも，<code>@JMSHeader</code>アノテーションと同様に，
					<code>bindingType</code>メンバによるバインディングの制御を指定することができます．
				</p>
				<p>
					setterメソッドに対しても<code>@JMSProperty</code>アノテーションを指定することができます．
					<code>name</code>メンバを省略した場合，
					メソッド名から先頭の"<code>set</code>"を取り除いて先頭を小文字にした名前がプロパティ名となります
					("<code>set</code>"を取り除いた名前の先頭2文字がどちらも大文字の場合は先頭を小文字にしません)．
				</p>
			</subsection>

			<subsection name="メッセージペイロードデータのバインド">
				<p>
					ヘッダと同様にメッセージの本体 (ペイロードデータ) もバインドすることができます．
				</p>
				<p>
					<code>MapMessage</code>を除いて，
					以下のようにフィールドやsetterメソッドに<code>@JMSPayload</code>アノテーションのみを指定した場合，
					メッセージのペイロードデータがバインドされます．
					この例の場合，<code>TextMessage</code>のペイロードデータである文字列がバインドされます．
				</p>
<source><![CDATA[
  @JMSPayload
  private String text;
]]></source>
<source><![CDATA[
  @JMSPayload
  public void setText(String text){
      this.text = text;
  }
]]></source>
				<p>
					<code>MapMessage</code>の場合，
					以下のようにフィールドやsetterメソッドに<code>@JMSPayload</code>アノテーションのみを指定した場合，
					ペイロードデータからフィールド名に一致するマッピングの値がバインドされます．
					この例の場合，<code>MapMessage</code>のペイロードデータから，
					<code>foo</code>というキーにマッピングされている値がバインドされます．
				</p>
<source><![CDATA[
  @JMSPayload
  private int foo;
]]></source>
<source><![CDATA[
  @JMSPayload
  public void setFoo(int foo){
      this.foo = foo;
  }
]]></source>
				<p>
					また，以下のように<code>name</code>メンバを利用してキーを明示することもできます．
				</p>
<source><![CDATA[
  @JMSPayload(name = "baz")
  public void setBar(String bar) {
      this.bar = bar;
  }
]]></source>
				<p>
					ただし，フィールドまたはプロパティの型が<code>Map</code>の場合は，
					<code>MapMessage</code>のペイロードが持つ全てのマッピングを含んだ
					<code>Map&lt;String, Object&gt;</code>がバインドされます．
				</p>
<source><![CDATA[
  @JMSPayload
  public void setBaz(Map baz) {
      this.baz = baz;
  }
]]></source>
				<p>
					<code>@JMSPayload</code>アノテーションにも，<code>@JMSHeader</code>アノテーションと同様に，
					<code>bindingType</code>メンバによるバインディングの制御を指定することができます．
				</p>
			</subsection>
		</section>

		<section name="リスナ・メソッド">
			<p>
				受信したメッセージがバインドされた後に呼び出されるのがリスナ・メソッドです．
			</p>
			<p>
				リスナ・メソッドは，デフォルトではメソッド名が<code>onMessage</code>のメソッドです．
			</p>
<source><![CDATA[
  public void onMessage() {
    ...
  }
]]></source>
			<p>
				引数を一つ持つこともできます．
				引数の型はメッセージのペイロードデータ型か，<code>javax.jms.Message</code>です．
			</p>
<source><![CDATA[
  public void onMessage(String text) {
    ...
  }
]]></source>
<source><![CDATA[
  public void onMessage(Message message) {
    ...
  }
]]></source>
			<p>
				また，以下のように<code>@OnMessage</code>アノテーションで任意の名前のメソッドをリスナ・メソッドにすることができます．
			</p>
<source><![CDATA[
  @OnMessage
  public void foo() {
    ...
  }
]]></source>
<source><![CDATA[
  @OnMessage
  public void bar(Map payload) {
    ...
  }
]]></source>
			<p>
				いずれも，戻り値の型は任意です．
				S2JMS-Containerが戻り値を利用することはありません．
			</p>
		</section>

		<section name="リクエスト～リプライ">
			<p>
				要求メッセージを受信した後に応答メッセージを送信する，リクエスト～リプライ型のアプリケーションは次のように実現することができます．
			</p>
<source><![CDATA[
public class RequestReplyListener {
    @Binding(bindingType = BindingType.MUST)
    private MessageSender sender;

    @JMSHeader
    private String messageID;

    @JMSPayload
    private String requestMessage;

    public void onMessage() {
        String replyMessage = ...;
        sender.setCorrelationID(messageID);
        sender.send(replyMessage);
    }
}
]]></source>
		</section>
	</body>
</document>
