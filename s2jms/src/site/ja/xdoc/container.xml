<?xml version="1.0" encoding="UTF-8"?>
<document>
	<properties>
		<title>Core</title>
	</properties>
	<body>
		<section name="目次">
			<ul>
				<li><p><a href="#概要">概要</a></p></li>
				<li><p><a href="#メッセージのバインド">メッセージのバインド</a></p>
					<ul>
				  	    <li><p><a href="#メッセージヘッダのバインド">メッセージヘッダのバインド</a></p></li>
				  	    <li><p><a href="#メッセージプロパティのバインド">メッセージプロパティのバインド</a></p></li>
				  	    <li><p><a href="#メッセージペイロードデータのバインド">メッセージペイロードデータのバインド</a></p></li>
					</ul>
				</li>
				<li><p><a href="#リスナ・メソッド">リスナ・メソッド</a></p></li>
				<li><p><a href="#SMART deploy">SMART deploy</a></p>
					<ul>
						<li><p><a href="#リスナ・コンポーネントの規約">リスナ・コンポーネントの規約</a></p></li>
						<li><p><a href="#diconファイルの設定">diconファイルの設定</a></p></li>
					</ul>
				</li>
				<li><p><a href="#フィルタ">フィルタ</a></p>
					<ul>
						<li><p><a href="#フィルタの作成">フィルタの作成</a></p></li>
						<li><p><a href="#標準のフィルタ">標準のフィルタ</a></p></li>
						<li><p><a href="#フィルタの設定">フィルタの設定</a></p></li>
					</ul>
				</li>
				<li><p><a href="#Tips">Tips</a></p>
					<ul>
						<li><p><a href="#リクエスト～リプライ">リクエスト～リプライ</a></p></li>
					</ul>
				</li>
			</ul>
		</section>

		<section name="概要">
			<p>
				S2JMS-Containerは，POJO (Plain Old Java Object) がJMSのAPIを意識することなく，
				非同期通信によるメッセージを受信できるようにするためのコンポーネントです．
			</p>
			<p>
				通常，JMSによるインバウンドメッセージ受信アプリケーション (EJBのMessage-Driven Beanなど)
				を作成するには，以下の手順を踏みます．
			</p>
			<ol>
				<li><p><code>javax.jms.MessageListener</code>インターフェースを実装したクラスを作成する．</p></li>
				<li><p><code>onMessage(javax.jms.Message)</code>メソッドを作成する．</p></li>
			 	<li><p><code>onMessage(javax.jms.Message)</code>メソッドの中で，受信した<code>javax.jms.Message</code>を処理する．</p></li>
			</ol>
			<p>
				しかし，この場合作成したクラスはJMSのAPIに依存することになってしまいます．
			</p>
			<p>
				S2JMS-Containerを利用することで，JMSのAPIに依存しない受信コンポーネント (Message-Driven POJOs)
				を作ることができ，特に既存の資産をJMS受信アプリケーションに流用することが容易となります
				(このメッセージ受信コンポーネントを，「リスナ・コンポーネント」と呼びます)．
			</p>
			<p>
				S2JMS-Containerは，インバウンド通信によりJMSメッセージを受信すると，
				JMSメッセージのヘッダやプロパティ，ペイロードをリスナ・コンポーネントにバインドしてメッセージを処理するメソッドを呼び出します
				(このメソッドを，「リスナ・メソッド」と呼びます)．
				このため，リスナ・コンポーネントは<code>javax.jms.MessageListener</code>インターフェースを実装したり，
				JMSメッセージを直接扱ったりすることなく，メッセージを処理することができます．
			</p>
		</section>

		<section name="メッセージのバインド">
			<p>
				S2JMS-Containerを使用すると，受信したJMSメッセージのヘッダ，プロパティ，およびペイロードを，
				リスナ・コンポーネントにバインドすることができます．
			</p>

			<subsection name="メッセージヘッダのバインド">
				<p>
					リスナ・コンポーネントに対して，受信したメッセージのヘッダをバインドします．
				</p>

				<p>
					バインドしたいフィールドまたはsetterメソッドに <code>@JMSHeader</code> アノテーションを指定することで，
					該当するメッセージヘッダがバインドされます．
				</p>
			
				<p>
					以下のように，<code>@JMSHeader</code>アノテーションのみを指定した場合，
					フィールド名に一致するメッセージヘッダがバインドされます．
					この場合，フィールド名は"<code>correlationID</code>" ("<code>JMS</code>"というプレフィックスをつけない)
					または"<code>JMSCorrelationID</code>" ("<code>JMS</code>"というプレフィックスをつける) のどちらでも有効です．
				</p>
				<p>
					以下の例では，<code>correlationID</code>フィールドに，
					<code>JMSCorrelationID</code>ヘッダの値がバインドされます．
				</p>
<source><![CDATA[
    @JMSHeader
    private String correlationID;
]]></source>
				<p>
					以下のように，<code>name</code>メンバを利用してヘッダ名称を指定することもできます．
					この場合，フィールド名には関係なく<code>name</code>メンバで指定されたヘッダ名が使用されます．
					この場合もヘッダ名称には「JMS」プレフィックスをつけてもつけなくても構いません．
				</p>
<source><![CDATA[
    @JMSHeader(name = "deliveryMode")
    private int mode;
]]></source>
				<p>
					<code>@JMSHeader</code>アノテーションには，
					S2Containerの<code>bindingType</code>メンバも指定することができます．
				</p>
<source><![CDATA[
    @JMSHeader(bindingType = BindingType.MUST)
    private String JMSMessageID;
]]></source>
				<p>
					<code>bindingType</code>については，以下の表を参照してください．
				</p>
				<table width="100%" border="1">
					<tr align="center">
						<th>bindingType</th>
						<th>説明</th>
					</tr>
					<tr>
						<td><code>MUST</code></td>
						<td>バインドに失敗した場合､例外が発生します．
					</td>
					</tr>
					<tr>
						<td><code>SHOULD</code> (デフォルト)</td>
						<td>バインドに失敗した場合､警告を通知します．</td>
					</tr>
					<tr>
						<td><code>MAY</code></td>
						<td>バインドに失敗した場合，何もおきません．</td>
					</tr>
					<tr>
						<td><code>NONE</code></td>
						<td>バインドを行いません．</td>
					</tr>
				</table>
				<p>
					setterメソッドに対しても<code>@JMSHeader</code>アノテーションを指定することができます．
					<code>name</code>メンバを省略した場合，
					メソッド名から先頭の"<code>set</code>"を取り除いた名前がヘッダ名となります．
					この場合もヘッダ名称には「JMS」プレフィックスをつけてもつけなくても構いません．
				</p>
<source><![CDATA[
    private int priority;
    
    @JMSHeader(name = "JMSPriority", bindingType = BindingType.MUST)
    public void setPriority(int priority) {
      this.priority = priority;
    }
]]></source>
			</subsection>

			<subsection name="メッセージプロパティのバインド">
				<p>
					ヘッダと同様にメッセージのプロパティもバインドすることができます．
				</p>
				<p>
					以下のように，フィールドやsetterメソッドに<code>@JMSProperty</code>アノテーションのみを指定した場合，
					フィールド名に一致するメッセージプロパティがバインドされます．
					この例の場合，「foo」という名前のプロパティがバインドされます．
				</p>
<source><![CDATA[
  @JMSProperty
  private int foo;
]]></source>
<source><![CDATA[
  @JMSProperty
  public void setFoo(int foo){
      this.foo = foo;
  }
]]></source>
				<p>
					また，以下のように<code>name</code>メンバを利用してプロパティ名を明示することもできます．
				</p>
<source><![CDATA[
  @JMSProperty(name = "baz")
  public void setBar(String bar) {
      this.bar = bar;
  }
]]></source>
				<p>
					<code>@JMSProperty</code>アノテーションの付けられたフィールドまたはプロパティの型が
					<code>java.util.Map</code>の場合は，
					全てのメッセージプロパティの名前とその値のマッピングを持つ<code>Map&lt;String, Object&gt;</code>が
					バインドされます．
				</p>
<source><![CDATA[
  @JMSProperty
  private Map<String, Object> properties;
]]></source>
				<p>
					<code>@JMSProperty</code>アノテーションにも，<code>@JMSHeader</code>アノテーションと同様に，
					<code>bindingType</code>メンバによるバインディングの制御を指定することができます．
				</p>
				<p>
					setterメソッドに対しても<code>@JMSProperty</code>アノテーションを指定することができます．
					<code>name</code>メンバを省略した場合，
					メソッド名から先頭の"<code>set</code>"を取り除いて先頭を小文字にした名前がプロパティ名となります
					("<code>set</code>"を取り除いた名前の先頭2文字がどちらも大文字の場合は先頭を小文字にしません)．
				</p>
			</subsection>

			<subsection name="メッセージペイロードデータのバインド">
				<p>
					ヘッダと同様にメッセージの本体 (ペイロードデータ) もバインドすることができます．
				</p>
				<p>
					<code>MapMessage</code>を除いて，
					以下のようにフィールドやsetterメソッドに<code>@JMSPayload</code>アノテーションのみを指定した場合，
					メッセージのペイロードデータがバインドされます．
					この例の場合，<code>TextMessage</code>のペイロードデータである文字列がバインドされます．
				</p>
<source><![CDATA[
  @JMSPayload
  private String text;
]]></source>
<source><![CDATA[
  @JMSPayload
  public void setText(String text){
      this.text = text;
  }
]]></source>
				<p>
					<code>MapMessage</code>の場合，
					以下のようにフィールドやsetterメソッドに<code>@JMSPayload</code>アノテーションのみを指定した場合，
					ペイロードデータからフィールド名に一致するマッピングの値がバインドされます．
					この例の場合，<code>MapMessage</code>のペイロードデータから，
					<code>foo</code>というキーにマッピングされている値がバインドされます．
				</p>
<source><![CDATA[
  @JMSPayload
  private int foo;
]]></source>
<source><![CDATA[
  @JMSPayload
  public void setFoo(int foo){
      this.foo = foo;
  }
]]></source>
				<p>
					また，以下のように<code>name</code>メンバを利用してキーを明示することもできます．
				</p>
<source><![CDATA[
  @JMSPayload(name = "baz")
  public void setBar(String bar) {
      this.bar = bar;
  }
]]></source>
				<p>
					ただし，フィールドまたはプロパティの型が<code>Map</code>の場合は，
					<code>MapMessage</code>のペイロードが持つ全てのマッピングを含んだ
					<code>Map&lt;String, Object&gt;</code>がバインドされます．
				</p>
<source><![CDATA[
  @JMSPayload
  public void setBaz(Map baz) {
      this.baz = baz;
  }
]]></source>
				<p>
					<code>@JMSPayload</code>アノテーションにも，<code>@JMSHeader</code>アノテーションと同様に，
					<code>bindingType</code>メンバによるバインディングの制御を指定することができます．
				</p>
			</subsection>
		</section>

		<section name="リスナ・メソッド">
			<p>
				受信したメッセージがバインドされた後に呼び出されるのがリスナ・メソッドです．
			</p>
			<p>
				リスナ・メソッドは，デフォルトではメソッド名が<code>onMessage</code>のメソッドです．
			</p>
<source><![CDATA[
  public void onMessage() {
    ...
  }
]]></source>
			<p>
				引数を一つ持つこともできます．
				引数の型はメッセージのペイロードデータ型か，<code>javax.jms.Message</code>です．
			</p>
<source><![CDATA[
  public void onMessage(String text) {
    ...
  }
]]></source>
<source><![CDATA[
  public void onMessage(Message message) {
    ...
  }
]]></source>
			<p>
				また，以下のように<code>@OnMessage</code>アノテーションで任意の名前のメソッドをリスナ・メソッドにすることができます．
			</p>
<source><![CDATA[
  @OnMessage
  public void foo() {
    ...
  }
]]></source>
<source><![CDATA[
  @OnMessage
  public void bar(Map payload) {
    ...
  }
]]></source>
			<p>
				いずれも，戻り値の型は任意です．
				S2JMS-Containerが戻り値を利用することはありません．
			</p>
		</section>

		<section name="SMART deploy">
			<p>
				リスナ・コンポーネントはSMART deployで自動登録することができます．
				HOT deployモードでは，S2JMS-Containerを利用したアプリケーションを再起動することなく，
				リスナ・コンポーネントを修正して確認することができます．
			</p>

			<subsection name="リスナ・コンポーネントの規約">
				<p>
					リスナ・コンポーネントのFQNは次のようになります．
				</p>
				<ul>
					<li><p><code><var>&lt;root&gt;</var>.listener.<var>Xxx</var>Listener</code></p></li>
				</ul>
				<p>
					インタフェースと実装を分離する場合は次のようになります．
				</p>
				<ul>
					<li><p><code><var>&lt;root&gt;</var>.listener.<var>Xxx</var>Listener</code> (インタフェース)</p></li>
					<li><p><code><var>&lt;root&gt;</var>.listener.impl.<var>Xxx</var>ListenerImpl</code> ()</p></li>
				</ul>
				<p>
					これらのコンポーネント名は，クラスの単純名 (FQNからパッケージを除いた名前) の先頭を小文字にしたものになります．
					ただし，クラス名の先頭2文字が大文字の場合はコンポーネント名の先頭2文字も大文字となります．
				</p>
				<ul>
					<li><p><code>root.listener.XxxListener</code> → <code>xxxListener</code></p></li>
					<li><p><code>root.listener.XXXListener</code> → </p><code>XXXListener</code></li>
				</ul>
				<p>
					<code>listener</code>パッケージ以下にサブパッケージを作成することもできます．
				</p>
				<ul>
					<li><p><code><var>&lt;root&gt;</var>.listener.aaa.<var>Xxx</var>Listener</code></p></li>
					<li><p><code><var>&lt;root&gt;</var>.listener.bbb.<var>Yyy</var>ListenerImpl</code></p></li>
				</ul>
				<p>
					サブパッケージを使った場合，コンポーネント名はサブパッケージ名がプレフィックスとして先頭に付加されます．
				</p>
				<ul>
					<li><p><code>root.listener.aaa.XxxListener</code> → <code>aaa_xxxListener</code></p></li>
					<li><p><code>root.listener.aaa.XXXListener</code> → </p><code>aaa_XXXListener</code></li>
				</ul>
				<p>
					コンポーネント名は，インバウンド通信の設定を行うdiconファイルで使用します．
					以下のように，<code>JMSContainerImpl</code>の定義の中で
					リスナ・コンポーネントのコンポーネント名を指定します．
				</p>
<source><![CDATA[
    <!-- S2JMS-Container の設定 -->
    <component class="org.seasar.jms.container.impl.JMSContainerImpl">
        <!-- アプリケーションのリスナ・コンポーネントの名前を指定します (複数指定可) -->
        <initMethod name="addMessageListener">
            <arg>"aaa_XxxListener"</arg>
        </initMethod>
    </component>
]]></source>
				<p>
					<code>JMSContainerImpl</code>の設定については，
					「<a href="config-inbound.html#JMSコンテナの設定">JMSコンテナの設定</a>」を参照してください．
				</p>
			</subsection>

			<subsection name="diconファイルの設定">
				<h4><code>creator.dicon</code></h4>
				<p>
					<code>creator.dicon</code>ファイルに<code>ListenerCreator</code>の定義を追加します．
				</p>
<source><![CDATA[
    <component class="org.seasar.jms.container.creator.ListenerCreator"/>
]]></source>
				<p>
					デフォルトでは，リスナ・コンポーネントはリクエストスコープになります．
				</p>

				<h4><code>customizer.dicon</code></h4>
				<p>
					<code>customizer.dicon</code>ファイルに<code>listenerCustomizer</code>の定義を追加します．
				</p>
<source><![CDATA[
    <component name="listenerCustomizer"
            class="org.seasar.framework.container.customizer.CustomizerChain">
        <initMethod name="addCustomizer">
            <arg>traceCustomizer</arg>
        </initMethod>
    </component>
]]></source>
				<p>
					JMSメッセージをトランザクショナルに受信するように設定されている場合，
					リスナ・コンポーネントはトランザクション境界内で呼び出されるため，
					<code>listenerCustomizer</code>にトランザクション制御のカスタマイザを設定する必要はありません．
					JMSメッセージをトランザクショナルに受信する設定については，
					「<a href="config-inbound.html#MessageEndpointFactory">MessageEndpointFactory</a>」を参照してください．
				</p>
			</subsection>
		</section>

		<section name="フィルタ">
			<p>
				フィルタを作成することにより，S2JMS-Containerが受信したJMSメッセージをリスナ・コンポーネントにバインドするまでの間に，
				様々な処理を行うことができます．
			</p>

			<subsection name="フィルタの作成">
				<p>
					フィルタは，次のインタフェースを実装したクラスです．
				</p>
				<ul>
					<li><p><code>org.seasar.jms.container.filter.Filter</code></p></li>
				</ul>
				<p>
					<code>Filter</code>インタフェースは次のメソッドを定義しています．
				</p>
				<ul>
					<li><p><code>void doFilter(Message message, FilterChain chain) throws Exception</code></p></li>
				</ul>
				<p>
					第2引数で渡される<code>FilterChain</code>は次のインタフェースです．
				</p>
				<ul>
					<li><p><code>org.seasar.jms.container.filter.FilterChain</code></p></li>
				</ul>
				<p>
					<code>FilterChain</code>は次のメソッドを定義しています．
				</p>
				<ul>
					<li><p><code>void doFilter(Message message) throws Exception</code></p></li>
				</ul>
				<p>
					フィルタの<code>doFilter(Message, FilterChain)</code>メソッドでは，
					メッセージを処理して<code>FilterChain#doFilter(Message)</code>を呼び出すことで
					後続のフィルタに制御を移すことができます．
				</p>
			</subsection>

			<subsection name="標準のフィルタ">
				<p>
					S2JMS-Containerでは，標準で次のフィルタを提供しています．
				</p>
				<dl>
					<dt><code>org.seasar.jms.container.filter.impl.TraceFilter</code></dt>
					<dd>
						リスナコンポーネントの呼び出し前後にトレースをログ出力するコンポーネントです．
					</dd>
					<dt><code>org.seasar.jms.container.filter.impl.DumpMessageFilter</code></dt>
					<dd>
						JMSメッセージの内容をログにダンプ出力するフィルタです．
					</dd>
					<dt><code>org.seasar.jms.container.filter.impl.RollBackFilter</code></dt>
					<dd>
						リスナコンポーネントまたはフィルタで例外が発生した場合にトランザクションをロールバックするフィルタです．
					</dd>
					<dt><code>org.seasar.jms.container.filter.impl.ExternalContextFilter</code></dt>
					<dd>
						JMSメッセージを外部コンテキストに設定するフィルタです．
						このフィルタにより，受信したJMSメッセージがリスナ・コンポーネントにバインドできるようになります．
					</dd>
					<dt><code>org.seasar.jms.container.filter.impl.HotdeployFilter</code></dt>
					<dd>
						HOT deployを有効にするためのフィルタです．
					</dd>
				</dl>
				<p>
					これらのフィルタは，上記の記述順で<code>jms-default-filter.dicon</code>に定義されています．
					<code>jms-default-filter.dicon</code>はS2JMS-ContainerのJarファイルの中に含まれています．
				</p>
			</subsection>

			<subsection name="フィルタの設定">
				<p>
					フィルタを使用するには，インバウンド通信の設定を行っている
					(<code>JMSContainerImpl</code>を定義している)
					diconファイルから，フィルタを定義しているdiconファイルをインクルードします．
				</p>
				<p>
					S2JMS-Containerの標準フィルタを使用する場合は次のようになります．
				</p>
<source><![CDATA[
    <include path="jms-default-filter.dicon"/>
    ・・・
    <component class="org.seasar.jms.container.impl.JMSContainerImpl">
        ・・・
    </component>
]]></source>
				<p>
					<code>JMSContainerImpl</code>の設定については，
					「<a href="config-inbound.html#JMSコンテナの設定">JMSコンテナの設定</a>」を参照してください．
				</p>
			</subsection>
		</section>

		<section name="Tips">
			<subsection name="リクエスト～リプライ">
				<p>
					要求メッセージを受信した後に応答メッセージを送信する，リクエスト～リプライ型のアプリケーションは次のように実現することができます．
				</p>
<source><![CDATA[
public class RequestReplyListener {
    @Binding(bindingType = BindingType.MUST)
    private MessageSender sender;

    @JMSHeader
    private String messageID;

    @JMSPayload
    private String requestMessage;

    public void onMessage() {
        String replyMessage = ...;
        sender.setCorrelationID(messageID);
        sender.send(replyMessage);
    }
}
]]></source>
				<p>
					受信した要求メッセージの<code>JMSMessageID</code>ヘッダの値を，
					応答メッセージの<code>JMSCorrelationID</code>ヘッダ設定します．
				</p>
			</subsection>
		</section>
	</body>
</document>
